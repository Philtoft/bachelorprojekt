C Primer. C Primer: TEACHER. Willard Rafnsson. SLIDES. Slides-5.pdf. FORM. EXECISES. LECTURE. DONE. WEEK. 39. C Primer: C Primer. R. eadings. Lecture. 1. Pointers. Notation. Why pointers in C: Pointers. Pointer Arithmetic. Array and pointers NOTATIONS. Pointers are NOT arrays. 2. Declarations and definitions. Scope of variables. 3. Type specifiers and qualifiers. Type specifiers. Type specifier: Struct. Type specifier: Union. Type specifier: Enum. Type qualifier: const. Type qualifier: volatile. void *. 4. Type conversions. Unsigned and signed. Pointer conversions. 5. Symbol overloading. Keyword overloading. Symbol overloading. 6. Operator precedence. 7. Unscrambling declarations. The rules for understanding C declarations. 8. Take-aways. R eadings: Chapter Machine-Level Representation of Programs. CS:APP 3.7. Procedures. CS:APP 3.8. Array Allocation and Access. CS:APP 3.9. Heterogeneous Data Structures. CS:APP 3.10. Combining Control and Data in Machine-Level Programs. Lecture: Agenda. Pointers. Declarations and definitions. Type specifiers and qualifiers. Type conversions. Symbol overloading. Operator precedence. Unscrambling declarations. Terms this week. dec, def, types, ops, pointers. 1. Pointers: "A pointer is a variable that contains the address of a variable.". Pointers let C programmers directly control CPU addressing. Notation: p. is a char pointer. It is a variable that contains the address of a char variable. Why pointers in C: To share data without copies. To manage indirections (more on this later with function pointers). To manage data placement / locality and memory allocation. Exercise. Write type declarations for the following variables: q: a pointer to an integer pointer. int q;. t: a pointer to a byte. char *t;. u: a pointer to a byte array. char *u[10];. Exercise. Consider the following code: What is wrong: Pointers: Pointers are valid, null or indeterminate. A pointer is null when assigned 0. Null pointers evaluate to false in logical expressions. Dereferencing indeterminate pointers leads to undefined behaviour. Always initialize pointers: Pointer Arithmetic: You can do arithmetic on the address. How far you skip, depends on the type of pointer. Array and pointers NOTATIONS: They can be used interchangeably: a[i]. is equivalent to. *(a+i). Regardless of whether a is declared as an array or a pointer. Pointers are NOT arrays: Arrays have a size, pointers do not. int* a;. int b[10];. a = b;. a. now points to. &b[0]. , the size is lost. Arrays. are assigned an. address in memory at compile time. , while. pointers. are assigned an. address in memory at run time. int* a;. int b[10];. a = b;. 2. Declarations and definitions: Definition. allocates memory to an entity. A. declaration. does not allocate memory to the entities. Once you define an entity, you cannot keep repeating the definition process again and again. Definition: specifies what a function does or where a variable is stored. Declaration.: describes the type of a variable/function and its name. No space is allocated. Variables and functions are defined exactly once,. but may be declared several times. Scope of variables: In C, as oppose to Java, you can have local static variables. These can only be initialized and updated once. A variable defined in a function is local to that function. It is an automatic variable. It does not retain its value across function calls. A variable defined outside any function is an external variable. It is a global variable. A global variable does not need to be declared in the file where it is defined. Before a global variable can be accessed in other files, it must be declared with the extern prefix. The scope of a global variable can be restricted to the file where it is defined with the static prefix. The keywords static and extern are mutually exclusive. An automatic variable can retain its value across calls to a function when it is defined with the static prefix. You. cannot. have: A function that returns a function never. foo()(). A function that returns an array never. foo()[]. An array of function never. foo[](). But you. can. have. A function returning a pointer to a function. *fun() (). A function returning a pointer to an array. *fun()[]. An array of function pointers. *foo. 3. Type specifiers and qualifiers: In C language. both the global and static variables must be initialized with constant values. This is because the values of these variables must be known before the execution starts. A. header file. is a file with extension.h. which contains C function declarations and macro definitions to be shared between several source files. There are two types of header files: the files that the programmer writes and the files that comes with your compiler. Type specifiers: char. ,. int. ,. short. ,. long. ,. float. ,. double. signed. /. unsigned. Pointer: *. Array: []. Struct. Union. Enum. Call by value. There are two methods to pass the data into the function in C language, i.e.,. call by value. and. call by reference. Type specifier: Struct: Struct: a bunch of data items grouped together (in memory). struct tag {. type_1 identifier_1;. type_2 identifier_2;. type_N identifier_N;. };. struct tag variable_name;. The data items in a struct are accessed through the dot operator. When using a pointer to struct, the data items dereferenced through the pointer are accessed through the arrow operator. These two structs are equivalent. struct {. unsigned int age = 3;. } Age;. struct Age {. unsigned int age = 3;. };. /* struct that points to the next struct */. struct node_tag {. int datum;. struct node_tag *next;. };. struct node_tag a,b;. a.next = &b;. a.next->next=NULL;. Padding. is a term used to describe the process of filling a field with pad characters. For example, if a name field required ten characters and your name was "Bob" (3 characters) the field would be "Bob0000000" where the 0's are the padding characters. Type specifier: Union: Unions have a similar appearance to structs, but the memory layout has one crucial difference. Instead of each member being stored after the end of the previous one, all the members have an offset of zero. The storage for the individual members is thus overlaid: only one member at a time can be stored there. union bits32_tag {. int whole; /* a 4B value */. struct {char c0,c1,c2,c3;} byte; /* 4 * 1B values */. }. Type specifier: Enum: Enums (enumerated types) are simply a way of associating a series of names with a series of integer values. enum sizes { small=7, medium, large=10, humungous };. Type qualifier: const: const. qualifies a read-only variable; one that cannot be a left value in an assignment following the variable declaration. Type qualifier: volatile: Volatile qualifies a variable that might be modified outside the program. For example, a register that can be modified by a device can be tested/read repeatedly by a program that never modifies it directly. Assigning a volatile object to a pointer results in undefined behaviour. struct devregs {. unsigned short volatile csr;. unsigned short const volatile data;. };. void *: void *. defines a pointer to data of unspecified type. 4. Type conversions: Explicit: A value of one type is explicitly cast to another type. Implicit: A value of one type is assigned to a variable of a different type. An operator converts the type of its operands. A value is passed as argument to a function or when a value is returned from a function. Unsigned and signed: Same bit level representation, different interpretations. If there is a mix of unsigned and signed in single expression, signed values are implicitly cast to unsigned. Pointer conversions: A pointer to one type of value can be converted to a pointer to a different type. However, the result may be undefined because of the alignment requirements and sizes of different types in storage. A pointer to an object can be converted to a pointer to an object whose type requires less or equally strict storage alignment, and back again without change. A pointer to void can be converted to or from a pointer to any type, without restriction or loss of information. If the result is converted back to the original type, the original pointer is recovered. If a pointer is converted to another pointer with the same type but having different or additional qualifiers, the new pointer is the same as the old except for restrictions imposed by the new qualifier. A pointer value can also be converted to an integral value. The conversion path depends on the size of the pointer and the size of the integral type: If the size of the pointer is greater than or equal to the size of the integral type, the pointer behaves like an unsigned value. It cannot be converted to a floating value. If the pointer is smaller than the integral type, the pointer is first converted to a pointer with the same size as the integral type, then converted to the integral type. Conversely, an integral type can be converted to a pointer type according to the following rules: If the integral type is the same size as the pointer type, the conversion simply causes the integral value to be treated as a pointer (an unsigned integer). If the size of the integral type is different from the size of the pointer type, the integral type is first extended or truncated to fit the size of the pointer. It is then treated as a pointer value. 5. Symbol overloading: Keyword overloading: Symbol overloading: 6. Operator precedence: Always put parentheses around an expression that mixes booleans, arithmetic, or bit manipulation with anything else. 7. Unscrambling declarations: Run. cdecl. to figure out a funky declaration. The rules for understanding C declarations: Declarations are read by starting with the name (of the variable, function or type). The following precedence rules apply: Parentheses grouping together part of the declaration. The postfix operators. Parenthesis indicating a function. Square brackets indicating an array. The prefix operator. denoting a pointer to. If a const or volatile is next to a type specifier it qualifies it, otherwise const or volatile applies to the * on its immediate left. 8. Take-aways: You should remember: A pointer is a variable that contains the address of a variable. The difference between declaration and definition. The scope of variables (automatic / global). The difference between type qualifier and specifier. The meaning of const and volatile. The nature of structs. When type conversions takes place. What happens when signed and unsigned are mixed. Beware operator precedence. Use. cdecl. when in doubt about a declaration.