Android Development. Android Components. Activities. Represents a single screen with a user interface, in-short Activity. performs actions on the screen and answer to the events on the UI. components. Services. A service is a component that runs in the application background to. perform long-running operations. User services: when the user starts a service, the app tells. App services. Broadcast Receivers. Broadcast Receivers simply respond to broadcast messages from other. application or from the Android operating system. Content Providers. A content provider component supplies data from one application to. others on request. Introduction to Kotlin tirsdag 8. februar. Variable: Var indicates that you want to declare a new variable. Read-only variable: Val indicates a new immutable variable, a constant. App Resources and Basic UI tirsdag. 15. februar. Android App Manifest. Package name: Determine the location of code entities when building your project. Permissions: Set permissions to access content from the app, e.g. access contacts. in WhatsApp. Components: Information about activities, services, broadcast receivers and. content providers. Requirements: Requirements of software and hardware. Color and style in res folder. Intent class. Explicit Intents. - Used in the context of your application, in which you can start. internal components. You define what will happen when you do something,. mapping activity. You explicitly state what you want. Implicit Intents. E.g I want to take a photo. You can say “I want to send a. mail”, then it can be suggested that you want to open the mail. app, but you don’t explicitly say what you want the phone to do, you imply it. Aim to start a component in another application. More in lecture 9. Android Jetpack. Suite of Android libraries to reduce boilerplate code, like lifecycle. management, background tasks. Reduce complexity with libraries that work consistently across Android. versions and devices. By lazy, means I will only instantiate this if I use it, or else it. doesn’t exist. Share objects/data between activities with intent. Material design and. fragments tirsdag 22. februar. One critical difference between the fragment lifecycle and the activity. lifecycle is that fragment lifecycle functions are called by the. FragmentManager of the hosting activity, not the OS. The OS knows. nothing about the fragments that an activity is using to manage things. Fragments are the activity’s internal business. The. onAttach(Context?), onCreate(Bundle?), onCreateView(. ), and. onViewCreated(. ). functions are called when you add the fragment to the. FragmentManager. Difference between activity and fragment: Activity has three steps: Java/Kotlin class file, XML layout and add to. manifest. Fragments do not need to be added in the manifest, only two files,. namely: Java/Kotlin class file and XML layout. On rotate, update savedInstanceState to resume to where you were on the. screen. ViewHolder is not mandatory with list view, but it is the best way to. do it, also with performance. But with recycle view, it is necessary. with a view holder. RecyclerView library must be added as a dependency library in your. project. Slide #5 page 5. Views use ViewHolders and Adapters to select a small sample form a. large data set. It only provides a limited number of the items that can be shown in the. screen. Flexible Data View and Thread. RecyclerView vs ListView. When an item scrolls off the screen, RecyclerView doesn’t destroy. its view. RecyclerView adapter forces the developer to use the ViewHolder. pattern. LayoutManager allows us to choose that we want to show the row views. and how to scroll. Notifying Adapter Recycle - View’s adapter provides a set of. notifiers to react while the data are binding to the view. If your application requires an operation that does not return an. immediate result, you must perform this operation in a separated thread. know as worker thread. Android provides the following threads. components: Android Thread: A block of code responsible to execute a set of tasks in your. application. Kotlin Coroutines: Kotlin coroutines provide an api that enables you to write asynchronous. code. Android handler: It allows you to send and process "messages" and. "runnable objects”. Download data from the internet, slide 54. Set on the manifest. You only need to ask for permission once. When to use async? When you don’t have control over how much time. something takes. Android services: Activites. Services:A Service is an Android component that can perform. long-running operations in the background. Once started, a service. might continue running for some time, even after the user switches to. another application. Local tests: Execute on your development machine or a server, so they’re also. called host-side tests. Instrumented tests: Execute on an Android device (phone, smartwatch,. tablet), either physical or emulated. Internal vs external memory: External example: Micro SD card, removable storage medium. GPS. The satellite sends you a very precise timestamp.You need at least. three satellites to provide a precise location. Android sensors: Motion sensors. Environmental sensors. Position sensors. Exam Practice. The Android application lifecycle;. One critical difference between the fragment lifecycle and the activity. lifecycle is that fragment lifecycle functions are called by the. FragmentManager of the hosting activity, not the OS. The OS knows. nothing about the fragments that an activity is using to manage things. Fragments are the activity’s internal business. The. onAttach(Context?), onCreate(Bundle?), onCreateView(. ), and. onViewCreated(. ). functions are called when you add the fragment to the. FragmentManager. Activity State Diagram. Every instance of an activity has a lifecycle. During the lifecycle,. the activity transitions between four states: resumed, paused, stopped. and nonexistent. For each transaction, there is an Activity function. that notifies the activity of changes of the state. The nonexistent state represents an activity that has not been launched yet, or an. activity that was just destroyed (for example by the user pressing the. back button). For that reason this state is sometimes referred to as the. destroyed state. There is no instance in memory, and there is no. associated view for the user to see or interact with. Stopped represents an activity that has an instance in memory, but whose. view is not visible on the screen. This state occurs in passing when the. activity is first spinning up, and re-occurs any time the view is fully. occluded (such as when the user launches another full-screen activity to. the foreground, presses the home button, or uses the overview screen to. switch tasks). Paused represents an activity that is not active in the foreground, but whose. view is visible or partially visible. An activity would be partially. visible, for example if the user launched a new dialog-themed or. transparent activity on top of it. An activity could also be fully. visible but not in the foreground if the user is viewing two activities. in multi window mode (also called “split screen. mode”). Resumed represents an activity that is in memory, fully visible and in. the foreground. It is the activity the user is currently interacting. with. Only one activity across the entire system can be in the resumed. state at any given time. That means that if one activity is moving into. the resumed state, another is likely moving out of the resumed. state. Subclasses of Activity can take advantage of the functions named in the. figure, to get work done at critical transitions in the activity’s. lifecycle. These functions are often called lifecycle callbacks. You are already acquaninted with one of these lifecycle callback. functions -onCreate(Bundle?). The OS calls this function after the. activity instance is created but before it is put onscreen. An activity usually overrides the increase to prepare the UI (inflating. the layout, setContentView, listeners etc.). When you finish an activity, onPause, onStop and then onDestroy is. called. Pressing the back button destroys the activity and starts a new. one. Rotating your device changes the device configuration. The device. configuration is a set of characteristics that describe the current. state of an individual device. When. Runtime configuration change. occurs, there may be resources that ar a better match for the new. configuration. So Android destroys the activity and looks for resources. that are the best fit for the new configurations and then rebuilds a new. instance of the activity with those resources. Fragment Lifecycle and Fragment Manager. The FragmentManager is a part of the activity class. It handles two. things: a list of fragments and a back stack of fragment transactions. It is responsible for adding the fragments’ views to the. activity’s view hierarchy and driving the fragments. lifecycles. Fragmentmanager is good when you have multiple fragments in one. activity. To add a fragment to an activity in code, you make explicit calls to. the activity’s FragmentManager. You can access the. activity’s fragment manager using supportFragmentManager. The. FragmentManager maintains a back stack of fragment transactions that you. can navigate. Diagram of the Fragment Lifecycle. The Fragment lifecycle is similar to the activity lifecycle. It has. stopped, paused and resumed states, and you can override them to get. things done at critical points. A fragment works on behalf of an activity, so its state should reflect. the activity’s state. Thus it need corresponding lifecycle. functions to handle the activity’s work. A critical difference between the fragment lifecycle and the activity. lifecycle is that fragment lifecycle functions are called by the. FragmentManager of the hosting activity, not the OS. The OS knows. nothing about the fragments that an activity is using to manage things. Fragments are the activity’s internal business. OnActivityCreated is called after the hosting activity’s onCreate. has been executed. What happens if you add a fragment while the activity. is already resumed? In that case, the FragmentManager immediately walks. the fragment through whatever steps are necessary to get it caught up to. the activity’s state. Example it calls onAttach, onCreate,. onCreateView etc. The four different types of Android components, namely: (1). activities, (2) services, (3) broadcast receivers, and (4) content. providers;. Activities. Activity represents a single screen with a UI and it is the entry point. for interacting with the user. Example for my app: my app had two activities: loginActivity and. ScooterSharingActivity. The ScooterSharingActivity connected to all the. other fragments. When to use activities and fragments: Fragments are Android's solution to creating reusable user. interfaces. You can achieve some of the same things using activities and. layouts (for example by using includes). Fragments, as tablets emerged with larger screens, are reusable. components that are attached to and displayed within activities. The ActionBar is super clever with fragments. If you want tabs up there. to navigate your app, you quickly see that ActionBar.TabListener. interface gives you a FragmentTransaction as an input argument to the. onTabSelected method. You could probably ignore this, and do something. else and clever, but you'd be working against the API, not with. it. The FragmentManager handles «back» for you in a very clever. way. Back does not mean back to the last activity, like for regular. activities. It means back to the previous fragment state. You can reuse code a lot: We need to mention all activity it in the manifest.xml file, not. fragments. Services. Services are the entry point for keeping an app running in the. background for all kinds of reasons. When the user starts a service, the. app tells the OS to run the service in background with a notification to. tell the user about it. A Background Service is a service that runs only when the app is. running so it'll get terminated when the app is terminated. A. Foreground Service is a service that stays alive even when the app is. terminated. Foreground A foreground service performs operations that are noticeable. to the user. For example, an audio app would use a foreground service to. play an audio track. Background A background service performs an operation that isn't. noticed by the user. The process like schedule syncing of data or. storing of data fall under this service. The process like schedule. syncing of data or storing of data fall under this service. And a Bound Service is a service that runs only if the component it is. bound to is still active. Bound A bound service offers a client-server interface that allows. components to interact with the service, send requests, receive results,. and even do so across processes with interprocess communication. (IPC). In my app, I used a foreground service for running the ride even when. the app was not open/screen was locked. This was showed as a. notification. Other example: service might play music in the background while. the user is in a different app without blocking the user interaction. with an activity, or fetch data over the network to the Android. application. Broadcast Receivers. They allow the system to deliver events to the app outside of a regular. user flow. Broadcast Receivers simply respond to broadcast messages from. other application or from the Android operating system. You can develop. your own custom broadcast to send or receive broadcast messages about. the devices and system components. Broadcasts originate from the OS: a. broadcast announcing that the screen has turned off, the battery is low,. or a picture was captured. The scooter-sharing application uses the broadcast receiver to send. data from the foreground service to the UI/main thread. The data itself. is sent as (wrapped in) a broadcast intent, similar to the command. dispatching to the service. Content Providers. A content provider component supplies data from one application to. others on request. They manage a shared set of app data that can be. persisted at any storage location your app can access. Content providers. are also useful for reading and writing data that is private to your app. and not shared. Example from my app: the camera is accessed for photographing and. scanning qr codes. Other example: The OS provides a content provider that manages the. user's contact information. As such, any app with the proper. permissions can query the content provider, to read and write. information about a contact. The design of user interfaces (UI) using layouts, resources, and a. set of Android UI controls (e.g., TextView, EditText, Button,. Checkbox, Progressbar, among others);. The user interface is designed using xml layout file which is connected. to the activity or fragment. You can write code or design directly. You. can also import predesigned buttons etc from material design for a. better look. Resources is a folder containing values, strings, themes. and so on, and is stored there for enabling a better structure and. reusing code. Especially strings and images can be saved there with and. ID, and then easily referred to by using the ID. ListView. ListView is a scrollable collection of views where each view is. positioned immediately below the previous view in the list. List items. requests views on demand from a ListAdapter as needed as the user. scrolls up or down. You must implement an Adapter which holds items from. a dataset and binds them to the list. You also must implement a. ViewHolder pattern to make our scrolling list smoother. RecyclerView. Recycler View is a user interface component that allows you create and. display dynamically a list of child View objects from a collection, one. for each item in your list of items. It uses ViewHolders and Adapters to select a small sample from a large. data set.It only provides a limited number of the items that can be. shown in the screen. In general, RecyclerView makes it easy to efficiently display large. sets of data than a ListView because: Recycling: When an item scrolls off the screen, RecyclerView. doesn't destroy its view. ViewHolder: RecyclerView’s adapter forces the developer to use. the ViewHolder pattern. LayoutManager: It allows us to choose the way that we want to show. the row views and how to scroll the list. Notifying Adapter: RecycleView’s adapter provides a set of. notifiers to react while the data are binding to the view. The items in your RecyclerView are arranged by a LayoutManager. The. RecyclerView library provides three layout managers, which handle the. most common layout situations: Linear Layout This layout arranges the items of a RecyclerView in a. one-dimensional list. Grid Layout The items in a row have the same height (vertical) or in a. column have the same width (horizontal). Staggered Layout It is similar to the grid layout, but it does not. require that items in rows and columns have the same size. ViewPager. ViewPager is a user interface component that allows the user to flip a. fragment to the left and right through pages of data. It uses a. PagerAdapter to generate the pages of fragments to be shown. Adapters. BaseAdapter is an abstract class that you need to implement all the. Adapter methods. ArrayAdapter is a complex implementation that works for data in arrays. or collections (ArrayList). How to share data between Android components, how to persist data. using files and databases, and how to manage the internal and external. file storages;. Singletons. A singleton is a class that allows only ONE instance of itself to be. created, and it exists as long as the application stays in memory. A. singleton exists as long as the application stays in memory, so storing. any properties on the singleton will keep them available throughout any. lifecycle changes in your activities and fragments. However, singletons do have a few downsides. For example, while they. allow for an easy place to stash data with a longer lifetime than a. controller, singletons do have a lifetime. Singletons will be destroyed,. along with all of their instance variables, as Android reclaims memory. at some point after you switch out of an application. Singletons are not. a long-term storage solution. (Writing the files to disk or sending them. to a web server is.). Persisting UI State - ViewModel. ViewModel is a lifecycle extension used to save the instance state on. rotation or other changes in ui. A ViewModel is related to one particular screen, and is a great place. to put logic involved in formatting the data to display on that screen. It holds on to a model object and “decorates” the model,. adding. Viewmodel is good for keeping track of if the activity is. finished, or just paused, so to know if it should reset the content and. memory, or just pause it. Shared Preferences. Save the UI state, user preferences or application settings as a set of. key/ value pairs of primitive data. The data from shared preferences are stored in the app’s sandbox. Therefore, it can be shared only between the app’s components. Use. the method apply() to save the changes asynchronously or the method. commit() to save the changes synchronously. You have to use serialization to save an object into the Shared. Preferences. Therefore, you can convert the object instance into a JSON. representation, then save the parsed data as a String. Internal and External storage - Write/Read data in files. Android supplies access to file-management tools to help you deal with. the file system. In Android, these tools are available from the. application Context: Read: FileInputStream is an useful class to read data from files in. the form of sequence of bytes. Write: FileOutputStream is a byte stream class that is used to handle. raw binary data. Delete: The method deleteFile() deletes a given private file. associated with this Context's application. List of Files: The method fileList() returns an array with all files. created by the current application. java.io.File, java.io.FileInputStream and File Mode Parameter can be. used to read files from internal storage. The external storage is great for files that you want to share with. other apps. If you want to write and read files in the external storage,. you must setup a permission in the AndroidManifest.xml. Before reading. or writing files in the external storage, you should always verify if. the volume is available. Sometimes, the external storage might be. unavailable, e.g. the user has removed the SD card from the. device. After you request storage permissions and verify that storage is. available, you can save two different types of files in the external. file storage, namely: Public files: Files freely available to other apps and to the user. These files remain available to the user even after uninstalling the. application. Private files: Files that rightfully belong to the application and. will be deleted when the user uninstalls the app. Text Files Text files can load and write temporary cache in accessible. folders from internal and external file storages. An Android device has. two file storage areas, namely: internal and external storage. In. general, the internal storage is a non-volatile memory available in the. device. On the other hand, the external storage is a removable storage. medium such as a micro SD card. Internal vs external memory: External example: Micro SD card, removable storage medium. External storage is not always available, it’s world-readable,. when uninstalling the app, it DOESN’T removes all app's files. External storage is the best when you want to share files with other. apps or allow the user to access with a computer. Internal example: RAM, ROM, flash memory, cache. Internal storage is always available, files accessed only by the app,. when uninstalling the app, also removes the app's files. Internal. storage is better when you want to be sure that neither the user nor. other apps can access your files. RoomDB. Room is a local database. The Room persistence library provides an. abstraction layer over SQLite to allow fluent database access while. harnessing the full power of SQLite. In particular, Room provides the. following benefits: Compile-time verification of SQL queries. Convenience annotations that minimize repetitive and error-prone. boilerplate code. Streamlined database migration paths. Entities are annotated classes used to describe a database table. You. have to define the attributes, constructor and mutator methods of your. entity class. @EntityThis annotation defines the current class as an entity of. your database. @PrimaryKeyThis annotation define the mandatory primary key of. your table. @NonNullThis annotation denotes that a parameter, field, or. method return value can never be null. @ColumnInfoThis annotation specifies the alternative name of the. column that represents the attribute in the table. A Data Access Object (DAO) is an interface or abstract class that. specifies the SQL queries and associates them with method of an Entity. class. @DaoThis annotation defines a data access object class for a. specific Entity class. Common QueriesYou can define SQL queries by the annotations. @Insert, @Update and @Delete. ThreadsBy default, all queries must be executed on a separate. thread in the repository. Personalized QueriesUse the annotation @Query to create more. complicated queries SQL-based queries. Update the dao - Kotlin Coroutines Create asynchronous code to keep the. app responsive while managing long tasks. SQLite. Android provides SQLite databases to be used to store and manager the. structured application data. Realm Database. Realm is an object database management system for mobile applications. It allows saving objects locally on the mobile device and two-way. synchronization between the MongoDB Realm Server and the client. Realm. is a cross-platform database solution that can be used as an alternative. to the traditional SQLite (Android Platform) and Core Data (iOS. Platform). It’s a NoSQL database, once it works only with live. native objects. SimplicityInstead of using SQL queries, you will deal with. objects and object trees in Realm. SpeedBecause there is no deserialization, it performs CRUD. operations in a fast way. Live ObjectsThe Realm data is only copied when your application. performs operations on them. Built-in AdaptersRealm has a set of Adapter classes to update. automatically the UI components. Downsides: Auto-Increment: You cannot increment primary keys values using a. Realm Database. Threads: You cannot pass Realm model classes between different. Threads. Restrictions: It is not allowed to override some object class methods. such as equals() and hashCode() when you implement one Entity using a. RealmObject. You need a realm recyclerview adapter. Firebase Realtime. The Firebase Realtime Database is a cloud-hosted NoSQL database that. lets you store and sync data between your users/applications in. real-time. A product from Google Firebase, which is a platform to help. developers build and run backend for mobile and web applications. Shared data: Realtime syncing makes it easy for your users to access. their data from any device, and it helps your users collaborate. Off-line usage: When users go offline, it uses a local cache on the. device to serve and store changes. It automatically synchronizes when. the users go online. Realtime: Any connected device receives the updates from your. database within milliseconds. Offline: Firebase apps remain responsive even when offline because. the database persists on your disk. Client Devices: The database can be accessed directly from a mobile. device or web browser. Scalability: You can support your app's data needs at scale by. splitting your data across multiple instances. Set Data and Listeners: Use these references to write data or. subscribe to changes. Secure Your Database: Use Firebase Realtime Database Security Rules. to secure your data. Create Database: Create a database for your project and uses. references to access the JSON data. Firebase Storage. Store and serve user-generated content. Cloud Storage for Firebase is a. powerful, simple, and cost-effective object storage service to store. images, audio, video, or other user-generated content. Robust Operations: It perform uploads and downloads regardless of. network quality. Strong Security: It integrates with Firebase Authentication to. provide simple access authentication. High Scalability: Effortlessly grow from prototype to production. using the same infrastructure of Spotify and Google. Photos Bucket: It stores your files in a Google Cloud Storage bucket,. making them accessible through both Firebase and Google Cloud. The use of concurrency to improve speed and performance in Android. applications (coroutines);. Threads in Android. A thread is a path of execution within a process. A process can contain. multiple threads. In Android, the applications run on a single thread of. execution called main, in which it is responsible for: User Interface: It dispatches events to the appropriate UI widgets,. for example drawing events. UI Toolkit: It allows your app interacts with components from the. Android UI toolkit. Callback Methods: Methods that respond to system callbacks always run. in the main thread of the app. ANR Dialog: If you block the main thread for more than 5 seconds, you. will see the ANR dialog. According to the official Android documentation, to handle more complex. interactions with a worker thread, you might consider using a Handler in. your worker thread, to process messages delivered from the UI. thread. Multiple threads in android: If your application requires an operation. that does not return an immediate result, you must perform this. operation in a separated thread know as worker thread. Android provides. the following threads components: Kotlin Coroutines: Kotlin coroutines provide an API that enables you to. write asynchronous code. With Kotlin coroutines, you can define a CoroutineScope, which helps. you to manage when your coroutines should run. Each asynchronous. operation runs within a particular scope. When to use async? When you don’t have control over how much time. something takes. The use of geolocation information to develop location-aware Android. applications;. Important factors when using the Android Location Manager: Startup time, battery consumption, provider availability, accuracy,. update rate. GPS stands for global positioning system. How to get location on a. smartphone: GPS, AGPS, Cell Towers, Wifi, Ble, NFC/Barcode. The best based on precision, speed and power usage must be NFC/Barcode,. BLE (bluetooth low energy) and Wi-Fi (maybe). In order to use location services, you must request the proper. permissions from the user, this is done in the Android Manifest. You ask. for permission to access the gps data (fine location) and cell towers. and wifi data (coarse location). Android has a set of location-based services (LBS) that allow you to. find the device's current location. We will use the Fused Location. Provider API because it is a simple and battery-efficient location API. for Android. Location API: Fused Location Provider API has created by Google to. the Google Play Services. Advantage: Fused Location Provider API is optimized to save the. battery life of your device. Further Information: Horizontal direction of travel, altitude,. velocity, etc. Dynamic Updates: Gets the location of the device at regular. intervals. How to manager the Fused Location API: You must start/stop the Fused Location Provider Client according to the. Activity or Framework life cycles. Therefore, it is necessary to. override the methods onResume and onPause with methods. subscribeToLocationUpdates() and unsubscribeToLocationUpdates(). Before. performing the method requestLocationUpdates(), you should explicitly. check if permission is available [using the method. checkSelfPermission()] or explicitly handle a potential. SecurityException. Geocoding is the process of transforming a street. address of a location into a (longitude, latitude) coordinate. Reverse. geocoding is the process of transforming a coordinate into a (partial). address. Android provides the class Geocoder that you can use to get the. current address. Google Maps. To use Google Maps API in your Android application, you must first. create your API Key from the Google Cloud Platform website. Google Cloud Platform is a suite of cloud computing services that runs. on the same infrastructure that Google uses internally for its end-user. products. Infrastructure: Use the most useful Google services using directly. Google’s infrastructure. Analytics: Easily capture, manage, process, and visualize data with. Google Cloud data analytics products. Serverless: Grow from prototype to production easily only think about. your source-code. Products: Google Cloud Platform provides over 100 products to be used. in your web and mobile applications. Maps SDK allows you to add maps to your Android app including Wear OS. apps using Google Maps data, map displays, and map gesture responses. Location Data: Your map can provide additional information for map. locations. User Interaction: Support user interaction by adding markers,. polygons, and overlays to your map. Languages: Maps SDK supports both the Kotlin and Java programming. languages. API Key + Fingerprint: It requires a combination of API Key and Hash. Fingerprint to access the Google Maps data. The development of multimedia applications using the built-in camera. and audio resources;. The Android multimedia framework includes support for playing variety. of common media types. Media Files: You can easily integrate audio, video and images into. your Android mobile applications. Data Source: You can play media files stored in your app's. resources, from files in the filesystem, or from a stream arriving. over a network connection. Media Player: You will play each sound file using the Android Media. Player. The Android multimedia framework includes support for playing. variety of common media types, so that you can easily integrate audio,. video and images into your applications. You can play audio or video. from media files stored in your application's resources (raw. resources), from standalone files in the filesystem, or from a data. stream arriving over a network connection, all using MediaPlayer. APIs. MediaPlayer: This class is the primary API for playing sound and. video. AudioManager: This class manages audio sources and audio output on a. device. In order to play multimedia files, you must give the proper permissions. for your app: Internet access, wake lock (to not lock the screen while. playing). For capturing video, you can choose between several API’s: Camera is the old API which can capture photos and simple video. recordings. Camera2 is a new API which supports fast and full resolution video. stream to capture resolutions above HD. CameraX is the newest, and is a Jetpack support library. You can also use camera intent (implicit intent). You need permission for both cameras, but it is essential to check if a. camera is available in the user's device. For example, Chromebooks. do not have a front camera. OpenCV. OpenCV is an open source library used to integrate real-time computer. vision methods in computational applications. This library has the. following features: Methods: more than 2500 optimized algorithms for basic computer. vision and pattern recognition. License: it is free for use in non- and commercial application under. the open-source BSD license. Cross-Platform: It is written natively in C/C++, but it is also. available for mobile development. Capabilities: f.ex Linear Algebra (Matrix Operations), Geometric. Transformation, Segmentation, Machine learning, Eye Tracking, Image. Processing. OpenCV life cycle. How to manage the video streaming: You must enable and disable the video streaming according to the. Activity or Framework life cycles. Therefore, it is necessary to. override the methods: OnResume(), OnPause() and OnDestroy(). Image analysis. Image analysis is a computational technique that aims to extract. meaningful information from digital images by means of digital image. processing. Digital Image: The image is represented in a N-D data structure with. integer values from 0 to 255 (8 bits). Pixels: Pixels are the smallest element of the image and can. represent from white (0) to black (255). OpenCV Mat: Mat is a data structure with a matrix header and a. pointer to the vector containing the pixels. Mat Header: Header contains information such as the matrix size,. number of channels in the image, etc. The use of device sensors (motion, position, environment, and. advanced sensors) to collect additional information for Android. applications;. Sensors OverviewMost android powered devices have built-in sensors that measure motion,. orientation and various environmental condition. These sensors are. capable of providing raw data with high precision and accuracy, and are. useful if you want to monitor three-dimensional device movement or. positioning. Or if you want to monitor changes in the ambient. environment near a device. Examples: a game might track readings from a device's gravity. sensor to infer complex user gestures and motions, such as tilt, shake,. rotation, or swing. Likewise, a weather application might use a. device's temperature sensor and humidity sensor to calculate and. report the dewpoint, or a travel application might use the geomagnetic. field sensor and accelerometer to report a compass bearing. Android devices have a set of hardware-based and software-based seniors. capable of providing high accuracy raw data. The official Android. documentation preset three broad categories of sensors: Motion sensors: a set of sensors used to measure accelaration forces. and rotational forces along the x-, y- and z-axes. Environmental sensors: a set of sensors used to measure environmental. parameters such as ambient air temperature, pressure, illumination and. humidity. Position sensors: a set of sensors used to measure the physical. position of a device. Motion sensors. The device motion is the reflection of direct user input (the device in. hand) or a reflection of the physical environment (e.g. the device. sitting in a car). Accelerometer: measure acceleration force applied to device on all 3. axes. Gravity: Measure the force of gravity that is applied to a. device on all 3 axes. Gyroscope: Measure a device’s rate of rotation in rad. Linear Acceleration: Measure the acceleration force in m/s^2. excluding the force of gravity. Rotation Vector: The rotation vector represents the orientation of. the device as a combination of an angle and an axis, in which the. device has rotated through an angle θ around an axis (x, y, or. z). Step Counter: This sensor provides the number of steps taken by the. user since the last reboot while the sensor was activated. The step. counter is accurate and has a latency up to 10 seconds. Environmental sensors. Environmental sensors measure various environmental parameters. They do. not require any data filtering and return a single sensor value for each. data event. Ambient temperature: returns the ambient room temperature in. degrees. Light: the ambient light sensor returns a value describing the. ambient illumination in lux. Pressure: returns the current atmospheric pressure in millibars. Relative humidity: this sensor returns the current relative humidity. as a percentage. Position Sensors: Device position and sensor to measure the distance between the. user's face and the device. Game Rotation Vector: It is identical to the rotation vector sensor,. but it doesn’t use the geomagnetic field. Geomagnetic Rotation Vector: It is similar to the rotation vector. sensor, but it doesn’t use the gyroscope. Magnetic Field: Measures the ambient geomagnetic field for all three. physical axes. Proximity: Measures the proximity of an object in cm relative to the. view screen of a device. Android sensor framework. Android Sensor Manager is a class used to manage a set of sensors. available in the mobile devices. You will use a Sensor object to access. some sensor properties, such as: type, name, manufacturer, accuracy,. range, among others. Data: Acquire raw data and define the minimum rate at which you. acquire sensor data. Listeners: Register and unregister sensor event listeners that. monitor sensor changes. Availability: Check which sensors are available on a mobile. device. Properties: Check an individual sensor property. Sensor Life Cycle. How to manager the Android Sensors: You must register/unregister the sensor event listener according to the. Activity or Framework life cycles. Therefore, it is necessary to. override the methods: OnResume() and OnPause(). Natural Device Orientation. The natural orientation of a device defines a value 0 for all three. axes. It is important to know the natural orientation before calculating. the device’s orientation. Position: The mobile device lying on its back on a desk and pointing. to the north. Orientation: On Android devices, the natural orientation can be. either portrait or landscape. Display: The display has its on natural position. Therefore, the. display orientation and device orientation can be different. G force: BlueTooth Protocol. Bluetooth is a protocol designed for short-range, low bandwidth. peer-to-peer communication between paired devices. Android SDK provides. a Bluetooth API that allow us to: Find paired Bluetooth devices. Search for new Bluetooth devices. Connect to one or multiple Bluetooth devices. Receive and transfer data through Bluetooth protocol. In Android devices, the Bluetooth communication is controlled by the. BluetoothAdapter class. This class provides a set of methods to read and. set the properties of the Bluetooth adapter. BlueTooth Low Energy - BLE Beacon. BLE is a wireless technology similar to Wi-FI. It allows devices to. communicate with each other through Bluetooth protocol. BLE is ideal for. situations where battery life is preferred over high data transfer. speeds. Signal: BLE Beacon devices regularly emits bluetooth radio signal in. a small range. Low Power: It uses batteries to power Bluetooth devices for several. days, months or years. Transfer Rate: BLE can achieve a data transfer rate of 200 Kbps. Connections: BLE can establish up to 20 connections. simultaneously. You have to use an Intent to active the Bluetooth sensor of your. device. On the other hand, use the method disable() to deactivate the. sensor. Android Broadcast Receivers. Android apps can send or receive broadcast messages from the Android. system and other Android apps. These broadcasts are sent when an event. of interest occurs or when something that the apps might be interested. in. Local: Use LocalBroadcastManager to send broadcasts to components of. your app. Security: Do not broadcast sensitive information using an implicit. intent. Main Thread: Because a receiver's onReceive(Context, Intent). method runs on the main thread, it should execute and return quickly. If you want to perform long running work, use threads or background. services. The security aspects of Android deployment to make an Android. application safer. Firebase Authentication. Add an end-to-end identify solution to your app for easy user. authentication, sign-in, sign-up, and sign-out. I have used Firebase Authentication in my app to make sure only. authenticated users can access the app and data. It supports sign in. with Facebook, Twitter, phone, gmail etc. ILO’s. design and implement a non-trivial Android application. identify the different types of Android components, their purpose and. lifecycle, and their role in the mobile application pipeline. describe the Android OS architecture, and how to build, run, and. debug a mobile app. design mobile applications based on the limitations and resources of. mobile platforms. design and implement mobile applications using different resources,. such as communication and multimedia, local and remote data. persistence, location-aware applications, built-in sensors, and mobile. concurrency. plan and execute the deployment of an Android application using. Android Studio. Testing: Testing your mobile app is an essential part of the app. development process. You can verify your app’s correctness,. functional behavior, and usability before you release it publicly. I have used local tests and instrumented tests. I have used Espresso. for instrumented tests. And JUnit 4 for unit tests. Unit tests for: ViewModels: Evaluate presenters to ensure the object recreation in. the middle of a process. Data: Testing corrupted data, malformed JSON, simulate full storage. when saving to file. Domain Layer: Evaluate the behavior of the middle-layer as with use. cases and interactions. Classes Testing: the attributes/methods of a class, such as math. operations and boundary conditions. Testing names and other input. Instrumented test. Screen User Interfaces Tests: Check critical user interactions in a. single screen. These tests perform actions such as clicking on. buttons, typing in forms, and checking visible states. User Navigation Tests: These tests simulate a user moving through a. navigation flow. They are simple tests, useful for checking for. run-time crashes in initialization or errors in the Android components. life cycle. develop native Android applications using the Kotlin programming. language. In kotlin we have variable/var and val. Variable: Var indicates that you want to declare a new variable. Read-only variable: Val indicates a new immutable variable, a. constant. Intents. An intent is an object that an Android component (activities, services,. broadcast receivers, or content providers) can use to communicate with. the OS. We separate between explicit and implicit intents. Explicit Intents. - Used in the context of your application, in which you can start. internal components. You define what will happen when you do something,. mapping activity. You explicitly state what you want. E.g opening. another activity. Implicit Intents. On the other hand, implicit intents aim to start a component in another. application. E.g I want to take a photo. You can say “I want to send a. mail”, then it can be suggested that you want to open the mail. app, but you don’t explicitly say what you want the phone to do,. you imply it. Aim to start a component in another application. You DO NOT need to specify an activity component, because the intent. provides information of available components provided by the system that. is to be invoked. If the Android operating system finds more than one capable component,. it will ask the user to choose one of the available options. Short on Flutter. Everything in Flutter is a widget, and all widgets have attributes that. allow for customization by passing other widgets. You can use a builder to make your scrollable ListView an out of the. box RecyclerView which lazily loads your content. Each view in your app requires a scaffold. It is what allows you to. program the app bar, the body, much more. Functionalities can be run asynchronously. Short on React Native. React native is a cross platform framework. You can write for mobile. and web. If offers fast-refresh (hot reload). When to use React Native: Limited budget/resources. Time-to-market is a high priority. Minimal sensor/hardware dependencies. 2 recyclerview and list view. Exam Questions: Android Components: Describe the four app components (activities, services,. broadcast receivers, and content provides) that are essential to. implement blocks of an Android app. You have to explain how each. component works in detail, how the user or mobile operating system can. interact with these components, and give us some examples of how to. use them in a mobile app. Foreground service: download file. It doesn’t stop when you close. the app. Background service stops when you do. The scooter-sharing application uses the broadcast receiver to send. data from the foreground service to the UI/main thread. The data itself. is sent as (wrapped in) a broadcast intent, similar to the command. dispatching to the service. They allow the system to deliver events to the app outside of a regular. user flow. Broadcast Receivers simply respond to broadcast messages from. other application or from the Android operating system. You can develop. your own custom broadcast to send or receive broadcast messages about. the devices and system components. Broadcasts originate from the OS: a. broadcast announcing that the screen has turned off, the battery is low,. or a picture was captured. User Interface Layout: Describe how to build the user interface of an Android app. You. have to explain the lifecycle of an Android app, compare the features. of some UI components (advantages and disadvantages), how to share. data between UI components, the use of app resources (e.g., colors,. string, layout), and the role of Android manifest file. Fragments: Describe what a fragment is and how it can be used. You must. discuss the advantages and disadvantages of using fragments instead of. activities, the fragment lifecycle, how to work with multiple. fragments, and how to share data between fragments. Adapters: Describe how to create a list to show a data collection in your. application. You must explain the role of your adapters in Android. applications, how to implement a custom adapter, how to use adapters. with ListView, RecyclerView, and ViewPager. Concurrency: Describe the principles of using threads in mobile. applications. You have to explain the features of UI threads and. worker threads, the differences between Android Threads, Android. Handlers and Kotlin Coroutines, how to control threads in mobile. applications, and give us some examples of how to choose one of the. Android threads to implement a specific task. Google Firebase: Describe how to build an entire backend for your Android. application using Google Firebase. You must explain how to setup a. Firebase project, the integration with Android apps, the primary. services available for mobile applications, and the security aspects. of using Firebase services. Testing: Describe the techniques used to test and evaluate Android. applications. You have to explain the fundamental concepts of testing. mobile applications, the differences between local tests and. instrumental tests, the primary libraries available to test your apps,. and how to plain a mobile application test. Data Persistency: Describe how to store locally and remotely the application data. from an Android app. You have to explain the differences between the. use of shared preferences, text files, and databases, the particular. features of internal and external file storages, private and public. files, object serialization, and how to implement a distributed system. to share data and multimedia files between multiple devices. Location Aware: Describe how to implement an Android geolocation-based. application. You have to explain how the GPS system works, how to. collect data from the GPS system, the kind of data available on the. GPS system, and how to integrate the GPS data with Google Maps. Multimedia: Describe how to use multimedia resources (audio and video) in. an Android app. You have to explain how to implement a service to play. sound files in an Android app, how to get images from a video. streaming, how to save images from the back and front cellphone. camera, and the use of the camera intent. Sensors: Describe how to collect and use data from Android sensors. You. have to explain the primary classification of Android sensors, the. main features of each Android sensor, how the Android Sensor Framework. works, and some examples of advanced sensors available on an Android. mobile device. Security: Describe some security aspects to make an Android application. safer and the most common techniques to access sensitive information. of a mobile app. You have to explain the primary security problems an. Android developer can face, when it is necessary to sign an Android. app, how to compress and obscure an Android app, the differences. between release and debug versions. 