[{"context": "C PrimerC Primer:TEACHERWillard RafnssonSLIDESSlides-5.pdfFORMEXECISESLECTUREDONEWEEK39C Primer:C PrimerReadingsLecture1. PointersNotationWhy pointers in C?PointersPointer ArithmeticArray and pointers NOTATIONSPointers are NOT arrays2. Declarations and definitionsScope of variables3. Type specifiers and qualifiersType specifiersType specifier: StructType specifier: UnionType specifier: EnumType qualifier: constType qualifier: volatilevoid *4. Type conversionsUnsigned and signedPointer conversions5. Symbol overloadingKeyword overloadingSymbol overloading6. Operator precedence7. Unscrambling declarationsThe rules for understanding C declarations8. Take-aways Readings:Chapter Machine-Level Representation of Programs. CS:APP 3.7 Procedures CS:APP 3.8 Array Allocation and Access CS:APP 3.9 Heterogeneous Data Structures CS:APP 3.10 Combining Control and Data in Machine-Level Programs Lecture:AgendaPointersDeclarations and definitionsType specifiers and qualifiersType conversionsSymbol overloadingOperator precedenceUnscrambling declarationsTerms this weekdec, def, types, ops, pointers1.", "questions_answers": [{"question": "What is the name of the C PrimerC Primer?", "answer": {"score": 0.528539776802063, "start": 17, "end": 54, "answer": "TEACHERWillard RafnssonSLIDESSlides-5"}}, {"question": "What are pointers in C?", "answer": {"score": 0.5662989616394043, "start": 122, "end": 150, "answer": "PointersNotationWhy pointers"}}, {"question": "What are the rules for understanding C declarations?", "answer": {"score": 0.8208611011505127, "start": 584, "end": 612, "answer": "Unscrambling declarationsThe"}}, {"question": "What is CS:APP 3.10 Combining Control and Data in Machine-Level Programs?", "answer": {"score": 0.48894891142845154, "start": 796, "end": 825, "answer": "Heterogeneous Data Structures"}}]}, {"context": "Pointers:\"A pointer is a variable that contains the address of a variable.\" Pointers let C programmers directly control CPU addressing.Notation:p is a char pointer. It is a variable that contains the address of a char variable.Why pointers in C?To share data without copies To manage indirections (more on this later with function pointers)To manage data placement / locality and memory allocationExerciseWrite type declarations for the following variables:q: a pointer to an integer pointerint **q;t: a pointer to a bytechar *t;u: a pointer to a byte arraychar *u[10];ExerciseConsider the following code:What is wrong?Pointers:Pointers are valid, null or indeterminate. A pointer is null when assigned 0 Null pointers evaluate to false in logical expressions Dereferencing indeterminate pointers leads to undefined behaviour.", "questions_answers": [{"question": "What is a pointer that contains the address of a variable?", "answer": {"score": 0.6844896078109741, "start": 0, "end": 8, "answer": "Pointers"}}, {"question": "What is notation:p a char pointer?", "answer": {"score": 0.379306823015213, "start": 171, "end": 226, "answer": "a variable that contains the address of a char variable"}}, {"question": "How are pointers valid, null or indeterminate when assigned 0 Null pointers evaluate to false?", "answer": {"score": 0.15651559829711914, "start": 684, "end": 688, "answer": "null"}}]}, {"context": "Always initialize pointers!Pointer Arithmetic:You can do arithmetic on the address. How far you skip, depends on the type of pointer.Array and pointers NOTATIONS:They can be used interchangeably:a[i] is equivalent to *(a+i) Regardless of whether a is declared as an array or a pointer.Pointers are NOT arrays:Arrays have a size, pointers do not. int* a; int b[10]; a = b; a now points to &b[0], the size is lost.Arrays are assigned an address in memory at compile time, while pointers are assigned an address in memory at run time. int* a; int b[10]; a = b; 2. Declarations and definitions:Definition allocates memory to an entity.", "questions_answers": [{"question": "What is the name of a pointer?", "answer": {"score": 0.07332322746515274, "start": 133, "end": 138, "answer": "Array"}}, {"question": "How many points do pointers have? What is an example of what type of pointer you can do arithmetic on?", "answer": {"score": 0.5696704387664795, "start": 75, "end": 82, "answer": "address"}}, {"question": "What are pointers that are NOT arrays?", "answer": {"score": 0.6824235916137695, "start": 309, "end": 327, "answer": "Arrays have a size"}}, {"question": "What is a difference between pointers and pointers?", "answer": {"score": 0.2743975520133972, "start": 399, "end": 411, "answer": "size is lost"}}]}, {"context": "A declaration does not allocate memory to the entities. Once you define an entity, you cannot keep repeating the definition process again and again.Definition: specifies what a function does or where a variable is stored. Declaration: describes the type of a variable/function and its name. No space is allocated. Variables and functions are defined exactly once, but may be declared several timesScope of variables:In C, as oppose to Java, you can have local static variables. These can only be initialized and updated once.A variable defined in a function is local to that function. It is an automatic variable.", "questions_answers": [{"question": "What is a declaration that does not allocate memory to the entities?", "answer": {"score": 0.04556020721793175, "start": 222, "end": 289, "answer": "Declaration: describes the type of a variable/function and its name"}}, {"question": "What is the name of a variable defined in a function?", "answer": {"score": 0.2916877567768097, "start": 591, "end": 612, "answer": "an automatic variable"}}, {"question": "How many times are variables defined in C as oppose to Java?", "answer": {"score": 0.48331934213638306, "start": 384, "end": 415, "answer": "several timesScope of variables"}}]}, {"context": "It does not retain its value across function calls. A variable defined outside any function is an external variable. It is a global variable. A global variable does not need to be declared in the file where it is defined. Before a global variable can be accessed in other files, it must be declared with the extern prefix.The scope of a global variable can be restricted to the file where it is defined with the static prefix. The keywords static and extern are mutually exclusive. An automatic variable can retain its value across calls to a function when it is defined with the static prefix.", "questions_answers": [{"question": "What is a variable defined outside a function?", "answer": {"score": 0.29059770703315735, "start": 95, "end": 140, "answer": "an external variable. It is a global variable"}}, {"question": "How can an automatic variable retain its value across calls to an function when defined with?", "answer": {"score": 0.43975257873535156, "start": 576, "end": 593, "answer": "the static prefix"}}, {"question": "What is an external variable?", "answer": {"score": 0.14354413747787476, "start": 52, "end": 91, "answer": "A variable defined outside any function"}}, {"question": "What does a global variable do not need to be declared in the file where it is defined?", "answer": {"score": 0.466005802154541, "start": 308, "end": 321, "answer": "extern prefix"}}]}, {"context": "You cannot have:A function that returns a function never foo()()A function that returns an array never foo()[]An array of function never foo[]()But you can haveA function returning a pointer to a function *fun() ()A function returning a pointer to an array *fun()[] An array of function pointers *foo 3. Type specifiers and qualifiers:In C language both the global and static variables must be initialized with constant values. This is because the values of these variables must be known before the execution starts.A header file is a file with extension .h which contains C function declarations and macro definitions to be shared between several source files.", "questions_answers": [{"question": "What is a file with extension.h which contains C function declarations and macro definitions to be shared between several source files?", "answer": {"score": 0.6018742322921753, "start": 516, "end": 529, "answer": "A header file"}}, {"question": "What is an array of function never foo()?", "answer": {"score": 0.01008231844753027, "start": 16, "end": 74, "answer": "A function that returns a function never foo()()A function"}}]}, {"context": "There are two types of header files: the files that the programmer writes and the files that comes with your compiler.Type specifiers:char, int, short, long, float, doublesigned / unsignedPointer: *Array: []StructUnionEnumCall by valueThere are two methods to pass the data into the function in C language, i.e., call by value and call by reference.Type specifier: Struct:Struct: a bunch of data items grouped together (in memory).struct tag { type_1 identifier_1; type_2 identifier_2; ... type_N identifier_N; }; struct tag variable_name;The data items in a struct are accessed through the dot operator. When using a pointer to struct, the data items dereferenced through the pointer are accessed through the arrow operator.", "questions_answers": [{"question": "What are the two types of header files that the programmer writes and the files that comes with your compiler?", "answer": {"score": 0.12403284013271332, "start": 118, "end": 133, "answer": "Type specifiers"}}, {"question": "What are two methods to pass the data into the function in C language?", "answer": {"score": 0.5308369994163513, "start": 207, "end": 240, "answer": "StructUnionEnumCall by valueThere"}}, {"question": "What is the name of a bunch of data items grouped together in memory?", "answer": {"score": 0.5305476784706116, "start": 365, "end": 378, "answer": "Struct:Struct"}}]}, {"context": "These two structs are equivalentstruct { unsigned int age = 3; } Age;struct Age { unsigned int age = 3; };/* struct that points to the next struct */ struct node_tag { int datum; struct node_tag *next; }; struct node_tag a,b; a.next = &b; a.next->next=NULL;Padding is a term used to describe the process of filling a field with pad characters. For example, if a name field required ten characters and your name was \"Bob\" (3 characters) the field would be \"Bob0000000\" where the 0's are the padding characters.Type specifier: Union:Unions have a similar appearance to structs, but the memory layout has one crucial difference.", "questions_answers": [{"question": "What are the two structs that are equivalentstruct  unsigned int age = 3?", "answer": {"score": 0.8290068507194519, "start": 69, "end": 105, "answer": "struct Age { unsigned int age = 3; }"}}, {"question": "What is a term used to describe the process of filling a field with pad characters?", "answer": {"score": 0.9684627056121826, "start": 257, "end": 264, "answer": "Padding"}}, {"question": "What is the name of a name field that required ten characters and your name was \"Bob\"?", "answer": {"score": 0.2735004723072052, "start": 257, "end": 264, "answer": "Padding"}}]}, {"context": "Instead of each member being stored after the end of the previous one, all the members have an offset of zero. The storage for the individual members is thus overlaid: only one member at a time can be stored there.union bits32_tag { int whole; /* a 4B value */ struct {char c0,c1,c2,c3;} byte; /* 4 * 1B values */ }Type specifier: Enum:Enums (enumerated types) are simply a way of associating a series of names with a series of integer values.enum sizes { small=7, medium, large=10, humungous };Type qualifier: const:const qualifies a read-only variable; one that cannot be a left value in an assignment following the variable declaration.", "questions_answers": [{"question": "What is the offset for the individual members?", "answer": {"score": 0.9563784599304199, "start": 105, "end": 109, "answer": "zero"}}, {"question": "What is a way of associating a series of names with integer values?", "answer": {"score": 0.49678435921669006, "start": 331, "end": 341, "answer": "Enum:Enums"}}, {"question": "What is const:const qualifies?", "answer": {"score": 0.6982758045196533, "start": 533, "end": 553, "answer": "a read-only variable"}}]}, {"context": "Type qualifier: volatile:Volatile qualifies a variable that might be modified outside the program. For example, a register that can be modified by a device can be tested/read repeatedly by a program that never modifies it directly. Assigning a volatile object to a pointer results in undefined behaviour.struct devregs { unsigned short volatile csr; unsigned short const volatile data; };void *:void * defines a pointer to data of unspecified type. 4. Type conversions:Explicit: A value of one type is explicitly cast to another type Implicit: A value of one type is assigned to a variable of a different type.", "questions_answers": [{"question": "What type qualifier qualifies a variable that might be modified outside of the program?", "answer": {"score": 0.5239346623420715, "start": 16, "end": 33, "answer": "volatile:Volatile"}}, {"question": "What can a register that can be modified by a device be tested/read repeatedly?", "answer": {"score": 0.25452566146850586, "start": 189, "end": 230, "answer": "a program that never modifies it directly"}}, {"question": "How does a volatile object be assigned to a pointer result in undefined behaviour?", "answer": {"score": 0.051803916692733765, "start": 232, "end": 241, "answer": "Assigning"}}]}, {"context": "An operator converts the type of its operands.A value is passed as argument to a function or when a value is returned from a function.Unsigned and signed:Same bit level representation, different interpretations.If there is a mix of unsigned and signed in single expression, signed values are implicitly cast to unsigned.Pointer conversions:A pointer to one type of value can be converted to a pointer to a different type. However, the result may be undefined because of the alignment requirements and sizes of different types in storage.A pointer to an object can be converted to a pointer to an object whose type requires less or equally strict storage alignment, and back again without change.", "questions_answers": [{"question": "What is an operator's type of operands?", "answer": {"score": 0.1688234806060791, "start": 0, "end": 29, "answer": "An operator converts the type"}}, {"question": "How can a pointer to one type of value be converted to?", "answer": {"score": 0.24833668768405914, "start": 404, "end": 420, "answer": "a different type"}}, {"question": "What is a value passed as argument to a function?", "answer": {"score": 0.8183424472808838, "start": 93, "end": 133, "answer": "when a value is returned from a function"}}, {"question": "What is the difference between unsigned and signed values?", "answer": {"score": 0.3863690197467804, "start": 154, "end": 210, "answer": "Same bit level representation, different interpretations"}}]}, {"context": "A pointer to void can be converted to or from a pointer to any type, without restriction or loss of information. If the result is converted back to the original type, the original pointer is recovered.If a pointer is converted to another pointer with the same type but having different or additional qualifiers, the new pointer is the same as the old except for restrictions imposed by the new qualifier.A pointer value can also be converted to an integral value. The conversion path depends on the size of the pointer and the size of the integral type:If the size of the pointer is greater than or equal to the size of the integral type, the pointer behaves like an unsigned value.", "questions_answers": [{"question": "What type can be converted to or from a pointer to void without restriction or loss of information?", "answer": {"score": 0.329140841960907, "start": 59, "end": 67, "answer": "any type"}}, {"question": "What type of pointer is recovered if the result is converted back to the original type?", "answer": {"score": 0.6448968052864075, "start": 0, "end": 17, "answer": "A pointer to void"}}, {"question": "What is the new pointer the same as the old except for restrictions imposed by the new qualifier?", "answer": {"score": 0.0658843144774437, "start": 201, "end": 264, "answer": "If a pointer is converted to another pointer with the same type"}}]}, {"context": "It cannot be converted to a floating value.If the pointer is smaller than the integral type, the pointer is first converted to a pointer with the same size as the integral type, then converted to the integral type. Conversely, an integral type can be converted to a pointer type according to the following rules:If the integral type is the same size as the pointer type, the conversion simply causes the integral value to be treated as a pointer (an unsigned integer).If the size of the integral type is different from the size of the pointer type, the integral type is first extended or truncated to fit the size of the pointer.", "questions_answers": [{"question": "What type of value can be converted to?", "answer": {"score": 0.5480409860610962, "start": 28, "end": 42, "answer": "floating value"}}, {"question": "What is the size of the pointer type?", "answer": {"score": 0.06002315133810043, "start": 142, "end": 155, "answer": "the same size"}}, {"question": "When is an integral type converted to a pointer?", "answer": {"score": 0.10339204967021942, "start": 43, "end": 91, "answer": "If the pointer is smaller than the integral type"}}, {"question": "How is the integral type treated as?", "answer": {"score": 0.2133302092552185, "start": 436, "end": 466, "answer": "a pointer (an unsigned integer"}}]}, {"context": "It is then treated as a pointer value 5. Symbol overloading:Keyword overloading:Symbol overloading: 6. Operator precedence:Always put parentheses around an expression that mixes booleans, arithmetic, or bit manipulation with anything else. 7. Unscrambling declarations:Run cdecl to figure out a funky declaration. The rules for understanding C declarations:Declarations are read by starting with the name (of the variable, function or type)The following precedence rules apply:Parentheses grouping together part of the declarationThe postfix operatorsParenthesis indicating a functionSquare brackets indicating an arrayThe prefix operatordenoting a pointer toIf a const or volatile is next to a type specifier it qualifies it, otherwise const or volatile applies to the * on its immediate left.", "questions_answers": [{"question": "What is a pointer value?", "answer": {"score": 0.9476557374000549, "start": 38, "end": 39, "answer": "5"}}, {"question": "What is the name of an expression that mixes booleans, arithmetic, or bit manipulation with anything else?", "answer": {"score": 0.9466907382011414, "start": 103, "end": 122, "answer": "Operator precedence"}}, {"question": "What are the following precedence rules for understanding C declarations?", "answer": {"score": 0.04437435790896416, "start": 477, "end": 562, "answer": "Parentheses grouping together part of the declarationThe postfix operatorsParenthesis"}}]}, {"context": "8. Take-aways:You should remember: A pointer is a variable that contains the address of a variable The difference between declaration and definitionThe scope of variables (automatic / global) The difference between type qualifier and specifier The meaning of const and volatileThe nature of structs When type conversions takes place What happens when signed and unsigned are mixed Beware operator precedence Use cdecl when in doubt about a declaration..", "questions_answers": [{"question": "What is a variable that contains the address of the variable What is the difference between declaration and definition?", "answer": {"score": 0.708524227142334, "start": 35, "end": 44, "answer": "A pointer"}}, {"question": "The difference between type qualifier and specifier The meaning of const and volatileThe nature of structs When type conversions takes place What happens when signed and unsigned are mixed Beware operator precedence Use cdecl when in doubt about a declaration?", "answer": {"score": 0.011250472627580166, "start": 333, "end": 345, "answer": "What happens"}}]}]